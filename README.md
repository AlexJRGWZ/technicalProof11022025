# TechnicalProof
## Overview
This repo contains the technical proof made for this case. Nextly, some topics of interests to pay attention at this proof

## Index
  1 - Guideline: to use this repo on local
  
  2 - Tecnologies: used
  
  3 - Architecture and design patterns: used
  
  4 - Others considerations

## Guideline to run this proof
  1. Clone this repository on an empty directory.
  
  2. Open your IDE and import this project as MavenProject

  3. With maven or directly from IDE use this commands:
     
      3.1. Maven clean or mvn clean
  
      3.2. Maven install or mvn install

      3.3. Run the project or mvn spring-boot:run
     
  4. Now you can check the microservices
  
  5. First time you make the mvn clean and mvn install, on directory target would be created you can encounter the directory surefire-reports, when there are the documentation generated by the tests made.
     
       5.1. You can delete the target directory to apply mvn clean install again and see the info of the tests.

## Technologies

The technologies used on this proof have been:
   - Spring version 3.4.2 with the next dependencies: SpringBoot, SpringWeb, SpringJPA, SpringH2, SpringTest
   - Maven version 3.8.8
   - Java version 23 (integrated with eclipse, see below)
   - Eclipse version 2024-12/R/e
   - Git and GitHub
   - H2 as DataBase
   - JUnit and Mockito to make the tests (added as dependency on the project)
   - Postman (not need, really works any navigator to proof the end-points appart of the tests)

## Architecture and design patterns

The architecture of this proof is similar at hexagonal architecture to web apps. On other words, the code of the app can be divide on the next sections or layers:
- <b>ModelLayer</b>: This layer will be used to mapping the database on a class of our project on Java. Will be contain the raw all data needly on mapping, including the differents relationships. On this layer, the relationships will be mapped with the own objects of the relationship. Is a normal class.
- <b>DTOLayer</b>: This layer will be used to format the Model Layer, on other words, will be used to replace the objects obtained with relationships on the ModelLayer for his correspondient id or value of the field that is used for the relationship. Is a normal class.
- <b>DAOLayer</b>: This layer will be used to filter the fields of the results, on other words, sometimes the app dont need all fields of the database for show the results on the web app. On this layer will be filtered the fields that we want filter ownly. Is a normal class.
- <b>RepositoryLayer</b>: This layer contain the repository using the Spring technology to connect with DataBase (H2 on this case). Will be use the String technology in conjunction with JPA to extract the data from DataBase. Is a interface that extends from JPARepository to use the Spring framework capabilities. On this layer, the data will be on format of ModelLayer.
- <b>Service</b>: This layer contains the definition of methods that will be used on the app, the first layer to obtain the data results and return at the correspondient controller. Is a interface, and contains the different definitions of method to develop. 
- <b>ServiceImpl</b>: This layer contains the implementation of the service layer. Is a class that implements the interface of the service on his own, overrading his methods. On this layer, the data return will be on ModelLayer format, relegating the format of results on the controller layer.
- <b>ControllerLayer</b>: This layer contain the controller used for return the data to the extern system correspondient. This layer contains the results and, depends of the nature of the extern system will return the DTO or DAO objects correspondients (preferred DAO objects). Will contain furthemore the private functions to convert from ModelLayer to DTOLayer or DAOLayer.

With these assumptions, the hexagonal architecture can be considered on the next form:
- <b>Domain-Core</b>: ModelLayer, DTOLayer and DAOLayer.
- <b>Ports</b>: RepositoryLayer, Service and ServiceImpl layers.
- <b>Adapters</b>: ControllerLayer

## Others considerations

On the directory of scriptBBDD, can be to encounter the init.sql, that contains the SQL sentences about the scheme and inserts on the table.

On the directory src/main/resources we can encounter the file with the properties of the project, and scheme.sql, data.sql that contains the sentences to create the initial values of databases when spring-boot will be launched.

On the directory target\surefire-reports there are the differents files of the tests and the results, although we can see the results on mvn clean install too (the code of reports is on src/tests)